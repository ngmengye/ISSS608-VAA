---
title: "Hands-on Exercise 06"
author: "Ng Meng Ye"
---

# Visualizing and Analysing Time-oriented Data

## Learning Outcome

By the end of this hands-on exercise you will be able create the followings data visualisation by using R packages:

-   plotting a calender heatmap by using ggplot2 functions,
-   plotting a cycle plot by using ggplot2 function,
-   plotting a slopegraph
-   plotting a horizon chart

## Getting Started

### Import Data

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| message: false
#| warning: false
pacman::p_load(scales, viridis, lubridate, ggthemes,
               gridExtra, readxl, knitr, data.table,
               CGPfunctions, ggHoriPlot, tidyverse)
```

## Plotting Calendar Heatmap

In this section, you will learn how to plot a calender heatmap programmatically by using ggplot2 package.

By the end of this section, you will be able to:

-   plot a calender heatmap by using ggplot2 functions and extension,
-   to write function using R programming,
-   to derive specific date and time related field by using base R and lubridate packages
-   to perform data preparation task by using tidyr and dplyr packages.

## The data

For the purpose of this hands-on exercise, eventlog.csv file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.

### Importing the data

```{r}
#| message: false
#| warning: false
#Reading the data into R environment
attacks <- read_csv("Data/eventlog.csv")
```

### Examining the data structure

It is always a good practice to examine the imported data frame before further analysis is performed.

For example, `kable()` can be used to review the structure of the imported data frame.

```{r}
#| message: false
#| warning: false
#Reading the data into R environment
kable(head(attacks))
```

There are three columns, namely *timestamp*, *source_country* and *tz*.

-   *timestamp* field stores date-time values in POSIXct format.
-   *source_country* field stores the source of the attack. It is in ISO 3166-1 alpha-2 country code.
-   *tz* field stores time zone of the source IP address.

### Data Preparation

Step 1: Deriving weekday and hour of day fields

Before we can plot the calender heatmap, two new fields namely wkday and hour need to be derived. In this step, we will write a function to perform the task.

```{r}
#| echo: false
#| message: false
#| warning: false
make_hr_wkday <- function(ts, sc, tz) {
  real_times <- ymd_hms(ts, 
                        tz = tz[1], 
                        quiet = TRUE)
  dt <- data.table(source_country = sc,
                   wkday = weekdays(real_times),
                   hour = hour(real_times))
  return(dt)
  }

```

::: callout-note
-   ymd_hms() and hour() are from lubridate package, and
-   weekdays() is a base R function.
:::

Step 2: Deriving the attacks tibble data frame

```{r}
#| echo: false
#| message: false
#| warning: false
wkday_levels <- c('Saturday', 'Friday', 
                  'Thursday', 'Wednesday', 
                  'Tuesday', 'Monday', 
                  'Sunday')

attacks <- attacks %>%
  group_by(tz) %>%
  do(make_hr_wkday(.$timestamp, 
                   .$source_country, 
                   .$tz)) %>% 
  ungroup() %>% 
  mutate(wkday = factor(
    wkday, levels = wkday_levels),
    hour  = factor(
      hour, levels = 0:23))

```

::: callout-note
Beside extracting the necessary data into attacks data frame, mutate() of dplyr package is used to convert wkday and hour fields into factor so theyâ€™ll be ordered when plotting
:::

Table below shows the tidy tibble table after processing.

```{r}
kable(head(attacks))
```

### Building the Calendar Heatmaps

```{r}
#| echo: false
#| message: false
#| warning: false
grouped <- attacks %>% 
  count(wkday, hour) %>% 
  ungroup() %>%
  na.omit()

ggplot(grouped, 
       aes(hour, 
           wkday, 
           fill = n)) + 
geom_tile(color = "white", 
          size = 0.1) + 
theme_tufte(base_family = "Helvetica") + 
coord_equal() +
scale_fill_gradient(name = "# of attacks",
                    low = "sky blue", 
                    high = "dark blue") +
labs(x = NULL, 
     y = NULL, 
     title = "Attacks by weekday and time of day") +
theme(axis.ticks = element_blank(),
      plot.title = element_text(hjust = 0.5),
      legend.title = element_text(size = 8),
      legend.text = element_text(size = 6) )
```

::: callout-note
-   a tibble data table called grouped is derived by aggregating the attack by wkday and hour fields.
-   a new field called n is derived by using group_by() and count() functions.
-   na.omit() is used to exclude missing value.
-   geom_tile() is used to plot tiles (grids) at each x and y position. color and size arguments are used to specify the border color and line size of the tiles.
-   theme_tufte() of ggthemes package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.
-   coord_equal() is used to ensure the plot will have an aspect ratio of 1:1.
-   scale_fill_gradient() function is used to creates a two colour gradient (low-high).
:::

### Building Multiple Calendar Heatmaps

*Challenge*: Building multiple heatmaps for the top four countries with the highest number of attacks.

count the attacks by country to see which ones are the most frequent.

```{r}
library(tidyverse) # Ensure tidyverse is loaded
library(ggthemes)  # For theme_tufte

# Count attacks by country
attacks_by_country <- attacks %>%
  count(source_country) %>%
  mutate(percent = n/sum(n)) %>%
  arrange(desc(n))

# Extract the names of the top 4 countries
top4 <- attacks_by_country$source_country[1:4]
```

Filter original attacks dataset to include only those top 4 countries. Group the data by country, weekday, and hour to get the counts for the heatmap tiles.

```{r}
# Filter and aggregate the data
top4_attacks <- attacks %>%
  filter(source_country %in% top4) %>%
  count(source_country, wkday, hour) %>%
  ungroup() %>%
  mutate(source_country = factor(source_country, levels = top4)) %>%
  na.omit()
```

Build the Multiple Heatmaps

```{r}
#| echo: false
#| message: false
#| warning: false
# Plot the heatmaps
ggplot(top4_attacks, 
       aes(x = hour, 
           y = wkday, 
           fill = n)) + 
  geom_tile(color = "white", size = 0.1) + 
  theme_tufte(base_family = "Helvetica") + 
  coord_equal() +
  scale_fill_gradient(name = "# of attacks",
                      low = "sky blue", 
                      high = "dark blue") +
  facet_wrap(~source_country, ncol = 2) +
  labs(x = NULL, y = NULL, 
       title = "Attacks weekday and time of day") +
  theme(axis.ticks = element_blank(),
        axis.text.x = element_text(size = 7),
        plot.title = element_text(hjust = 0.5),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 6))
```

### Plotting Multiple Calendar Heatmaps

Step 1: Deriving attack by country object

```{r}
attacks_by_country <- count(
  attacks, source_country) %>%
  mutate(percent = percent(n/sum(n))) %>%
  arrange(desc(n))
```

Step 2: Preparing the tidy data frame

```{r}
top4 <- attacks_by_country$source_country[1:4]
top4_attacks <- attacks %>%
  filter(source_country %in% top4) %>%
  count(source_country, wkday, hour) %>%
  ungroup() %>%
  mutate(source_country = factor(
    source_country, levels = top4)) %>%
  na.omit()
```

Step 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.

```{r}
#| echo: false
#| message: false
#| warning: false
ggplot(top4_attacks, 
       aes(hour, 
           wkday, 
           fill = n)) + 
  geom_tile(color = "white", 
          size = 0.1) + 
  theme_tufte(base_family = "Helvetica") + 
  coord_equal() +
  scale_fill_gradient(name = "# of attacks",
                    low = "sky blue", 
                    high = "dark blue") +
  facet_wrap(~source_country, ncol = 2) +
  labs(x = NULL, y = NULL, 
     title = "Attacks on top 4 countries by weekday and time of day") +
  theme(axis.ticks = element_blank(),
        axis.text.x = element_text(size = 7),
        plot.title = element_text(hjust = 0.5),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 6) )
```

## Plotting Cycle Plot

In this section, you will learn how to plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.

Step 1: Data Import

```{r}
air <- read_excel("Data/arrivals_by_air.xlsx")
```

Step 2: Deriving month and year fields

```{r}
air$month <- factor(month(air$`Month-Year`), 
                    levels=1:12, 
                    labels=month.abb, 
                    ordered=TRUE) 
air$year <- year(ymd(air$`Month-Year`))
```

Step 3: Extracting the target country

```{r}
USA <- air %>% 
  dplyr::select(`USA`, 
         month, 
         year) %>%
  filter(year >= 2010)
```

Step 4: Computing year average arrivals by month

```{r}
hline.data <- USA %>% 
  group_by(month) %>%
  summarise(avgvalue = mean(`USA`))
```

Step 5: Plotting the cycle plot

```{r}
#| echo: false
#| message: false
#| warning: false
ggplot() + 
  geom_line(data=USA,
            aes(x=year, 
                y=`USA`, 
                group=month), 
            colour="black") +
  geom_hline(aes(yintercept=avgvalue), 
             data=hline.data, 
             linetype=6, 
             colour="red", 
             size=0.5) + 
  facet_grid(~month) +
  labs(axis.text.x = element_blank(),
       title = "Visitor arrivals from USA by air, Jan 2010-Dec 2019") +
  xlab("") +
  ylab("No. of Visitors") +
  theme_tufte(base_family = "Helvetica")
```

## Plotting Slopegraph

Step 1: Import data

```{r}
rice <- read_csv("Data/rice.csv")
```

Step 2: Plotting the slopegraph


```{r}
library(tidyverse)

# Filter for the years used in the SMU exercise
rice_filtered <- rice %>%
  mutate(Year = factor(Year)) %>%
  filter(Year %in% c(1961, 1980))
```

```{r}
ggplot(data = rice_filtered, 
       aes(x = Year, y = Yield, group = Country)) +
  # Draw the slopes
  geom_line(aes(color = Country), size = 1, show.legend = FALSE) +
  # Add points at the ends
  geom_point(aes(color = Country), size = 3, show.legend = FALSE) +
  # Add text labels on the left (1961)
  geom_text(data = rice_filtered %>% filter(Year == 1961),
            aes(label = paste0(Country, " (", round(Yield, 1), ")")),
            hjust = 1.2, size = 3) +
  # Add text labels on the right (1980)
  geom_text(data = rice_filtered %>% filter(Year == 1980),
            aes(label = paste0(Country, " (", round(Yield, 1), ")")),
            hjust = -0.2, size = 3) +
  # Cleanup the theme to match Tufte's style
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank()) +
  # Expand limits to make room for labels
  scale_x_discrete(expand = expansion(mult = c(0.5, 0.5))) +
  labs(title = "Rice Yield Comparison", subtitle = "1961 vs 1980")
```
::: callout-note
For effective data visualisation design, `factor()` is used convert the value type of Year field from numeric to factor.
:::
